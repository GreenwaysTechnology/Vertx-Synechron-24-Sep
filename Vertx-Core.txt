
Linux system calls for building non blocking io apps
......................................................
select + read 
poll ->
epoll -> it is optimized poll api

Windows
 IOCP - non blocking io wrapper

Unix/Mac-bsd op

KQueue

WHo implemented first non blocking webserver.

nginx - first non blocking web server

node.js - second programmable non blocking applications written

java and non blocking io
.........................
NonBlocking io:
...............


IO:

Hardware devices typically provide the ability to input data into the computer or output data from the computer.

To simplify the ability to support a variety of hardware devices, standardized application programming interfaces (API) are used.

Application programs use the "System Call API" to request one of a finite set of preset I/O requests from the Operating System.

The Operating System uses algorithms for processing the request that are device independent.

The Operating System uses another API to request data from the device driver.

The device driver is third party software that knows how to interact with the specific device to perform the I/O.

Sometimes we have a layering of device drivers where one device driver will call on another device driver to facilitate the I/O.

 An example of this is when devices are connected to a USB port. The driver for the device will make use of the USB device driver to facilitate passing data to and from the device.

File Descriptor:
..................

File descriptor or file descriptor table is nothing but , it is "c" program which has all information about  io opertaions.

Fd is bridge between application runtime/process and io devices.


Blocking io code in java:
........................

blocking network socket app.


import java.io.*;
import java.net.InetSocketAddress;
import java.net.ServerSocket;
import java.net.Socket;

public class BlockingEco {
    public static void main(String[] args) throws Throwable {
        //this api interally communicates network interface card
        ServerSocket server = new ServerSocket();
        server.bind(new InetSocketAddress(3000));
        System.out.println("Blocking Socket : listening for new Request");
        while (true) {   // <1>
            Socket socket = server.accept();
            //each incomming request(socket request) allocate in a separate thread
            new Thread(clientHandler(socket)).start();
        }
    }

    private static Runnable clientHandler(Socket socket) {
        return () -> {

            try (
                    BufferedReader reader = new BufferedReader(
                            new InputStreamReader(socket.getInputStream()));
                    PrintWriter writer = new PrintWriter(
                            new OutputStreamWriter(socket.getOutputStream()))) {
                String line = "";
                while (!"/quit".equals(line)) {
                    line = reader.readLine();      // <2>
                    System.out.println("~ " + line);
                    writer.write(line + "\n");  // <3>
                    writer.flush();
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        };
    }

}

Why not blocking?

Blocking APIs waste resources, increase costs


The main problem with the code above ,is that it allocates a new thread for each incoming connection(request) and threads are anything but cheap resources. 

A thread needs memory, and the more threads you have, the more you put pressure on the operating system kernel scheduler, as it needs to give CPU time to the thread

 Input/output operations such as readLine and write may block the thread, meaning that it is being parked by the operating system. This happens for two reasons:

A read operation may be waiting for data to arrive from the network.
A write operation may have to wait for buffers to be drained if they are full from a previous write operation

NonBlocking io  = IO Multiplxing (Nonblocking io,SIGIO,POSX_IO FUNCTIONS)

Today there are two io programming models = blocking and io multiplexing(Non,async)

Generally all webservers work based on "Request per thread Model".

2000,C10K - concurrently handling ten thousand connections.

2000, Linux operating system introduced a new api for io operations which does not block thread - "select"	

non blocking io operation: 

1.select + read - first non blocking io operation introduced in linux operating system.

2.poll - second non blocking io operation api introduced in linux. the difference is 
         poll pushing data from kernal to application process rather pulling data          from  kernal table.

3.Epoll -  this modern non blocking io api introduced in linux....

Other Operating system non blocking abstractions:

EPoll -Linux
IOCP - Windows
kqueue -mac and other open bsd versions.
.....................................................................................
java and non blocking:
......................

Does java support non blocking apis?

No!

Yes from Java 7 called "Dolphin".

Dolphin introduced experimental model for building fast disk io, called "NIO"-NONBlocking IO.

NIO version: non blocking version

import java.io.IOException;
import java.net.InetSocketAddress;
import java.nio.ByteBuffer;
import java.nio.channels.SelectionKey;
import java.nio.channels.Selector;
import java.nio.channels.ServerSocketChannel;
import java.nio.channels.SocketChannel;
import java.nio.charset.Charset;
import java.util.HashMap;
import java.util.Iterator;
import java.util.regex.Pattern;

public class AsynchronousEcho {

  public static void main(String[] args) throws IOException {
    Selector selector = Selector.open();

    ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();
    serverSocketChannel.bind(new InetSocketAddress(3000));
    serverSocketChannel.configureBlocking(false);
    serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);

    while (true) {
      selector.select();
      Iterator<SelectionKey> it = selector.selectedKeys().iterator();
      while (it.hasNext()) {
        SelectionKey key = it.next();
        if (key.isAcceptable()) {
          newConnection(selector, key);
        } else if (key.isReadable()) {
          echo(key);
        } else if (key.isWritable()) {
          continueEcho(selector, key);
        }
        it.remove();
      }
    }
  }

  private static class Context {
    private final ByteBuffer nioBuffer = ByteBuffer.allocate(512);
    private String currentLine = "";
    private boolean terminating = false;
  }

  private static final HashMap<SocketChannel, Context> contexts = new HashMap<>();

  private static void newConnection(Selector selector, SelectionKey key) throws IOException {
    ServerSocketChannel serverSocketChannel = (ServerSocketChannel) key.channel();
    SocketChannel socketChannel = serverSocketChannel.accept();
    socketChannel
      .configureBlocking(false)
      .register(selector, SelectionKey.OP_READ);
    contexts.put(socketChannel, new Context());
  }

  private static final Pattern QUIT = Pattern.compile("(\\r)?(\\n)?/quit$");

  private static void echo(SelectionKey key) throws IOException {
    SocketChannel socketChannel = (SocketChannel) key.channel();
    Context context = contexts.get(socketChannel);
    try {
      socketChannel.read(context.nioBuffer);
      context.nioBuffer.flip();
      context.currentLine = context.currentLine + Charset.defaultCharset().decode(context.nioBuffer);
      if (QUIT.matcher(context.currentLine).find()) {
        context.terminating = true;
      } else if (context.currentLine.length() > 16) {
        context.currentLine = context.currentLine.substring(8);
      }
      context.nioBuffer.flip();
      int count = socketChannel.write(context.nioBuffer);
      if (count < context.nioBuffer.limit()) {
        key.cancel();
        socketChannel.register(key.selector(), SelectionKey.OP_WRITE);
      } else {
        context.nioBuffer.clear();
        if (context.terminating) {
          cleanup(socketChannel);
        }
      }
    } catch (IOException err) {
      err.printStackTrace();
      cleanup(socketChannel);
    }
  }

  private static void cleanup(SocketChannel socketChannel) throws IOException {
    socketChannel.close();
    contexts.remove(socketChannel);
  }

  private static void continueEcho(Selector selector, SelectionKey key) throws IOException {
    SocketChannel socketChannel = (SocketChannel) key.channel();
    Context context = contexts.get(socketChannel);
    try {
      int remainingBytes = context.nioBuffer.limit() - context.nioBuffer.position();
      int count = socketChannel.write(context.nioBuffer);
      if (count == remainingBytes) {
        context.nioBuffer.clear();
        key.cancel();
        if (context.terminating) {
          cleanup(socketChannel);
        } else {
          socketChannel.register(selector, SelectionKey.OP_READ);
        }
      }
    } catch (IOException err) {
      err.printStackTrace();
      cleanup(socketChannel);
    }
  }
}
Problmes with NIO :

It is also important to note that like most JDK APIs, java.nio focuses solely on what it does (here, I/O APIs).
 
->It does not provide higher-level protocol-specific helpers, like for writing HTTP clients and servers.
 
->Also, java.nio does not prescribe a threading model, which is still important to properly utilize CPU 
cores, handle asynchronous I/O events, and articulate the application processing logic.

->This is why, in practice, developers rarely deal with Java NIO. 
.......................................................................................................

Networking libraries like Netty and Apache Mina solve the shortcomings of Java NIO


NETTY

 "Netty is a NIO client server framework which enables quick and easy development of network applications such as protocol servers and clients. "

It greatly simplifies and streamlines network programming such as TCP and UDP socket server.

Unified API for various transport types - blocking and non-blocking socket

Based on a flexible and extensible event model which allows clear separation of concerns- The first Reactor Model on jvm.

        	     Netty Application
		             |
          	         nettycore
			     |
			    nio
			     |
		            jvm

Apache MINA 

  Apache MINA is a network application framework which helps users develop high performance and high scalability network applications easily.
 It provides an abstract event-driven asynchronous API over various transports such as TCP/IP and 

UDP/IP via Java NIO.
NIO framework library,
client server framework library, or
a networking socket library

		    Apache MINA 
		         |
          	      Minaapi
			 |
			nio
			 |
		        jvm


&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&


Vertx:

Birth of Vertx Project

Vertx was born to simulate Node.js Capability on JVM.
 initally it was named "Node.X"

A core project, called vertx-core, provides the APIs for asynchronous programming, non-blocking I/O, streaming, and convenient access to networked protocols such as TCP, UDP, DNS, HTTP or Web Sockets,

Vertx is industry ready , polyglot toolkit for building Non blocking,async,evented io applications.

Vertx has been built on the top of Netty Core.

			
			VertxApplication
			      |
			Vertx Core Runtime
			      |
			   Netty Core
			      |
			     NIO
			      |
			     JVM


Objective of VertX:
   
    100% non blocking applications on jvm.



                     NonBlocking IO Application -Verxt Application
   --------------------------------------------------------------------		
    Vertx-FS  Vertx-TCP/IP  Vertx-UDP Vertx-HTTP Vertx-HTTPS Vertx-SMTP .....
  ---------------------------------------------------------------------
			      |
			Vertx Core Runtime
			      |
			   Netty Core
			      |
			     NIO
			      |
			     JVM


Vert.x is poly glot:

 Vertx is java technology platform, Vertx runs on JVM.
 Fundamentally JVM supports multiple language as JVM Spec dt 2003.


	               Java PL  Groovy Kotlin  
	            	|       |     |         |         |     |
      -------------------------------------------------------------
                               .class
				                         |
   --------------------------------------------------------------------		
       Vertx-FS  Vertx-TCP/IP  Vertx-UDP Vertx-HTTP Vertx-HTTPS Vertx-SMTP .....
  ---------------------------------------------------------------------
			      |
			Vertx Core Runtime
			      |
			   Netty Core
			      |
			     NIO
			      |
			     JVM

......................................................................................

Vertx Runtime:

Vertx run time is powered by non blocking io arch

Vertx uses event loops
 -event loops are used to process events which are dispatched by kernal.
 -Event loops are just threads to process incoming events from kernal

Event :

  collection of event and data
  How to read data?
    you need handler- callback functions


Vert.x uses multi core event loop threads where as node js has only one event loop thread.

Vertx uses per cpu core - 2 event loop, lets say i have 12 cores - 12 *2 =24 event loops.
....................................................................................

Lets enter into vertx app; how to build non blocking and async apps:
....................................................................

Lets code:

-Vertx Project setup
   -Maven Project
   -Gradle Project

1.plain maven project, add vertx depedencies,You can use template entry method provided by vertx .

2.Vertx Starter project

3.Vertx maven cli project


.................................................................................
			 How to create vertx cli project..

https://start.vertx.io/

Vertx application can be small to big enterprise microservice application.

Like spring , starts with spring-core , after that ,spring-mvc,spring-data....(modules)

Vertx also begins modules

vertx-core ,vertx-web,vertx-data..............etc...

vertx-core:

How to run vertx app?

Every Vertx apps will have entry point, configured in pom.xml

 <main.verticle>com.amex.MainVerticle</main.verticle>
 <launcher.class>io.vertx.core.Launcher</launcher.class>

How to run vertx apps?

1.compile the code and execute - dev mode.

mvnw clean compile exec:java

[INFO] Scanning for projects...
[INFO] 
[INFO] -----------------------< com.amex:vertxcoreapp >------------------------
[INFO] Building vertxcoreapp 1.0.0-SNAPSHOT
[INFO] --------------------------------[ jar ]---------------------------------
[INFO] 
[INFO] --- maven-clean-plugin:2.5:clean (default-clean) @ vertxcoreapp ---
[INFO] 
[INFO] --- maven-resources-plugin:2.6:resources (default-resources) @ vertxcoreapp ---
[INFO] Using 'UTF-8' encoding to copy filtered resources.
[INFO] skip non existing resourceDirectory E:\session\AMex\2023\vertxcoreapp\src\main\resources
[INFO]                                                                                         
[INFO] --- maven-compiler-plugin:3.8.1:compile (default-compile) @ vertxcoreapp ---            
[INFO] Changes detected - recompiling the module!
[INFO] Compiling 1 source file to E:\session\AMex\2023\vertxcoreapp\target\classes
[INFO] 
[INFO] --- exec-maven-plugin:3.0.0:java (default-cli) @ vertxcoreapp ---
HTTP server started on port 8888
Oct 16, 2023 2:22:56 PM io.vertx.core.impl.launcher.commands.VertxIsolatedDeployer
INFO: Succeeded in deploying verticle

By default vertx offers some Webservice which is running in port 8888

http://localhost:8888/

2.Creating production apps -deployment 

mvnw clean package 

 This command gives two jars.
  
 Regular jar   - jar which has separate dependency - application has one jar , libs                  has another jar
 fat jar -  everything in one jar

How to run ?

java -jar target/vertxcoreapp-1.0.0-SNAPSHOT-fat.jar
.....................................................................................

Vert.x Learning Path:
.....................
1.Vert.x core
2.Vert.x Web apps - RESTFull API
3.Vert.x Reactive Programming - Using Rxjava or SmallRye Mutiny
4.Vert.x Database Programming
5.Microservices features and implementation

.....................................................................................
				Vert.x Core
.....................................................................................
			   vertx Core concepts
.....................................................................................

Core Vertx Concepts:
....................

1.Vertx Instance , so Called "Vertx Engine". === Spring Container
2.Verticles ; so called an Object through which you can create apps.

Vertx Engine is a java class, represented as interface in the io.vertx.core package

io.vertx.core package is core package

Vertx Instance:

 It is Object,Container Object. like Spring Container.

-it is entry and exit point of vertx application.
-on jvm(single) process can have single vertx instance.
-vertx can host other objects.

To create an instance of this class you can use the static factory methods:

 vertx(), 
 vertx(io.vertx.core.VertxOptions) 
 clusteredVertx(io.vertx.core.VertxOptions, Handler)

Vertx Instance can do 

Creating TCP clients and servers
Creating HTTP clients and servers
Creating DNS clients
Creating Datagram sockets
Setting and cancelling periodic and one-shot timers
Getting a reference to the event bus API
Getting a reference to the file system API
Getting a reference to the shared data API
Deploying and undeploying verticles

.....................................................................................
			   vertx Core concepts
.....................................................................................

Core Vertx Concepts:
....................

1.Vertx Instance , so Called "Vertx Engine". === Spring Container
2.Verticles ; so called an Object through which you can create apps.

Vertx Engine is a java class, represented as interface in the io.vertx.core package

io.vertx.core package is core package

Vertx Instance:

 It is Object,Container Object. like Spring Container.

-it is entry and exit point of vertx application.
-on jvm(single) process can have single vertx instance.
-vertx can host other objects.

To create an instance of this class you can use the static factory methods:

 vertx(), 
 vertx(io.vertx.core.VertxOptions) 
 clusteredVertx(io.vertx.core.VertxOptions, Handler)

Vertx Instance can do 

Creating TCP clients and servers
Creating HTTP clients and servers
Creating DNS clients
Creating Datagram sockets
Setting and cancelling periodic and one-shot timers
Getting a reference to the event bus API
Getting a reference to the file system API
Getting a reference to the shared data API
Deploying and undeploying verticles

package com.amex;

import io.vertx.core.Vertx;

public class HelloVertx {
  public static void main(String[] args) {
    System.out.println("Creating vertx app");
    Vertx vertx = Vertx.vertx();
    System.out.println(vertx.getClass());

    System.out.println("Main thread" + Thread.currentThread().getName());
    //create simple web server
    vertx.createHttpServer().requestHandler(req -> {
      System.out.println("Server");
      System.out.println("Vertx thread : " + Thread.currentThread().getName());
      req.response().end("Hello Vertx");
    }).listen(8080);

  }
}
.....................................................................................

Vertx modules:
...............
vertx-core
vertx-web
vertx-data
vertx-microservices
etc...

Verticles
Threading modles
callbacks
Promises
Futures


Verticle:
  -It is java object
  -It can be deployed and undeployed on vertx instance.

What is deployment?

The action of bringing "resources" into effective action

In vertx, Brining Resources ready  for computation.

Resources:
 -Thread creation /allocation
 -binding an object with that thread
 -Register all event handlers in case of event driven programming
 -Allocate memory if required for data/other 
 -Ensures that other depenendant resources are ready.

-It is based on design pattern called "Actor-like Model"
-Verticles are bound to "Event loop" , are processed by event loop threads.


Verticle is interface which provides life cycle methods 
  -init   - called when verticle being initalized
  -start - called when verticle during deployment
  -stop  - called when verticles during undeployment


if you are writing any verticle class, you cant use "Verticle" Interface directly.

Vertx provides an implementation abstract class called "AbstractVerticle" class.

Non Reactive:
io.vertx.core.AbstractVerticle

Reactive Implementation based:
io.vertx.rxjava3.core.AbstractVerticle
io.vertx.rxjava.core.AbstractVerticle
io.vertx.reactivex.core.AbstractVerticle


How to use Verticle?

 AbstractVerticle is base class for creating our own verticles.


eg:
 if you are going to implement servlet , 

public class MyServlet extends HttpServlet{

  init  
  doGet
  doPost
  destroy
}

package com.mycom;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Context;
import io.vertx.core.Promise;
import io.vertx.core.Vertx;

public class HelloWorldVerticle extends AbstractVerticle {
  //override life cycle method
  @Override
  public void init(Vertx vertx, Context context) {
    super.init(vertx, context);
    System.out.println("Init is called");
  }

  //whenever we deploy the verticle on vertx engine these methods are called auotmatically
  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    System.out.println("Start is called");
  }

  @Override
  public void stop() throws Exception {
    super.stop();
    System.out.println("Stop is called");
  }
}

.....................................................................................
	          How to create multiple verticles and deploy them
....................................................................................

There are many ways to deploy verticles

1.within main verticle and deploy other verticles
2.write simple java class and through which you can deployment
3.Vertx provides a runner class/Lanucher class through which also you can deploymnet


1.within main verticle and deploy other verticles

Main verticle has been configured in pom.xml

<main.verticle>com.mycom.MainVerticle</main.verticle>
<launcher.class>io.vertx.core.Launcher</launcher.class>

1.within main verticle and deploy other verticles


package com.amex;

import com.amex.verticles.GreeterVerticle;
import io.vertx.core.AbstractVerticle;
import io.vertx.core.Context;
import io.vertx.core.Vertx;

public class MainVerticle extends AbstractVerticle {
  //override verticle life cycle methods
  @Override
  public void init(Vertx vertx, Context context) {
    super.init(vertx, context);
    System.out.println("Init is called");
  }

  @Override
  public void start() throws Exception {
    super.start();
    System.out.println("Start method is called");
    //deploy Greeter Verticle
    //vertx variable is already available within every verticle we create.
    // vertx.deployVerticle(new GreeterVerticle());
    //vertx.deployVerticle(GreeterVerticle.class.getName());
    vertx.deployVerticle("com.amex.verticles.GreeterVerticle");

  }

  @Override
  public void stop() throws Exception {
    super.stop();
    System.out.println("stop method is called");
    vertx.undeploy("com.amex.verticles.GreeterVerticle");
  }
}
....................................................................................

....................................................................................

From plain java code how to deploy verticles?
.............................................

package com.amex;

import com.amex.verticles.GreeterVerticle;
import io.vertx.core.Vertx;

public class VertlcleDeployer {
  public static void main(String[] args) {
    Vertx vertx = Vertx.vertx();
    vertx.deployVerticle(new GreeterVerticle());
  }
}

This code will not call life cycle method like stop.
This is not recommended way of deploying verticles.

Runner/Lanucher class
.......................
Lanuching vertx applications using main method without using "maven/gradle" configuration.

import com.amex.verticles.GreeterVerticle;
import io.vertx.core.AbstractVerticle;
import io.vertx.core.Launcher;

public class LanucherDeployer extends AbstractVerticle {
  public static void main(String[] args) {
    Launcher.executeCommand("run", LanucherDeployer.class.getName());
  }

  @Override
  public void start() throws Exception {
    super.start();
    System.out.println("Deployer starting");
    vertx.deployVerticle(new GreeterVerticle());
  }

  @Override
  public void stop() throws Exception {
    super.stop();
    System.out.println("Deployer ending");
  }
}

Output:
Deployer starting
GreeterVerticle
Oct 16, 2023 4:37:14 PM io.vertx.core.impl.launcher.commands.VertxIsolatedDeployer
INFO: Succeeded in deploying verticle
GreeterVerticle has been stopped
Deployer ending

....................................................................................
			  Vertx Coding Style
...................................................................................

Patterns to write non blocking apps:

1.callback style -traditionals way.
2.Reactive style -Streaming pattern

In order to write non blocking apps,
  the os should support non blocking infrastructure - epoll,kqueue,iocp.
  The pl and frameworks should give apis to leverlage non blocking

Non blocking apis provided vertx.
1.timer - vertx.setPeriodic
2.http -vertx.createHttpServer()
3.fs
4.socket
5.database
etc.......

Callback/Listener Style:
1.Future
2.Promises

if you come from java script && node.js background,you know the concept called "Callback function" - callback function is other wise called as "listener function" or "handler function".

Handler Function /Callback function/Listener function:
.......................................................
1.Handler functions are not called by developers directly like other functions.
2.Handlers functions are called by a thread "Event Loop".
3.Handler functions are available inside Event Queue as passive instruction.
4.Once async operation(task-database connnection) is completed, os triggers event, along with event, data, and its   handler is pushed into event queue, event loop thread starts processing event by assinging a handler function.

What is handler function/callback function/listener function for?

 "To handle async success /failure result"
     "The result of async Operation could be either success or failure".

io.vertx.Future:

-it is interface used to handle async success/failure results.
-vertx uses Future(Object) to represent "Asynchronous" Results
-Future is like transport object to transport data between caller and callee in async  manner

Caller -------Future-----Callee


What type of data Future can carry?

-Success--------|
                  ---->Future -----Verticle----Thread---bound with event loop--events
-Failure--------|

AsynResult<T>:

Encapsulates the result of an asynchronous operation.

Object which has either success data or failure data.

If it failed then the cause of the failure is available with cause().

If it succeeded then the actual result is available with result()
...................................................................................

Future is interface , encapsulate response(Success/failure), we need to create Object 
for "Future" implementation

Future f = Future.future() // create FutureImpl object

Two major api for response:


1.complete()  and complete(T result) =>Success Response, encasulated inside this api

2.fail(String failureMessage) and fail(Throwable cause) =>Failure response, encapsulate  inside this api.

Handler apis for handling response;
...................................

1.succeeded() : empty response
2.default Future<T> onComplete(Handler<AsyncResult<T>> handler)
3.onSuccess
5.onFailure



AsyncResult interface apis

 -result() - get the success result sent by Future
 -cause()   -get the failure result sent by Future
 -succeed() -test whether it was success or failure
 -failed()  -test whether it was failure or success
....................................................................................

How to use Future Object to simulate async callbacks:
.....................................................

Use case : Without Data : Empty Future.
package com.amex.futures;

import io.vertx.core.*;

public class FutureDemoVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Launcher.executeCommand("run", FutureDemoVerticle.class.getName());
  }

  //Callee
  //create simple future and return no Result.
  public Future<Void> getEmptyFuture() {
    //create Future Object : Anonymous pattern using java inner class
//    Future<Void> future = Future.future(new Handler<Promise<Void>>() {
//      @Override
//      public void handle(Promise<Void> event) {
//        event.complete();
//      }
//    });
    // create Future Object : using lambda pattern:It is recommended
    Future<Void> future = Future.future(event -> {
      event.complete();
    });
    return future;
  }

  @Override
  public void start() throws Exception {
    super.start();
    System.out.println("Future Verticle");
    //caller
//    getEmptyFuture().onComplete(new Handler<AsyncResult<Void>>() {
//      @Override
//      public void handle(AsyncResult<Void> event) {
//        //here only we grab result
//        if (event.succeeded()) {
//          System.out.println("Success");
//          event.result();
//        } else {
//          System.out.println("Failed");
//          System.out.println(event.cause().getMessage());
//        }
//      }
//    });
    getEmptyFuture().onComplete(event -> {
      if (event.succeeded()) {
        System.out.println("Success");
        event.result();
      } else {
        System.out.println("Failed");
        System.out.println(event.cause().getMessage());
      }
    });
  }
}
....................................................................................

Future with Data , error:
.........................
package com.amex.futures;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Future;
import io.vertx.core.Launcher;

public class FutureWithData extends AbstractVerticle {
  public static void main(String[] args) {
    Launcher.executeCommand("run", FutureWithData.class.getName());
  }

  //Return data with Future.
  public Future<String> sayHello() {
    return Future.future(future -> future.complete("Hello"));
  }

  //return error data with Future
  public Future<String> getError() {
    return Future.future(future -> future.fail("Something went wrong!"));
  }

  //future with biz logic
  public Future<String> login(String userName, String password) {

    return Future.future(handler -> {
      //biz logic
      if (userName.equals("admin") && password.equals("admin")) {
        handler.complete("Login Success");
      } else {
        handler.fail("Login failed");
      }
    });

  }


  @Override
  public void start() throws Exception {
    super.start();
    //subscribe future .
    sayHello().onComplete(event -> {
      if (event.succeeded()) {
        System.out.println(event.result());
      } else {
        System.out.println(event.cause());
      }
    });
    //grab error Message
    getError().onComplete(event -> {
      if (event.failed()) {
        System.out.println(event.cause().getMessage());
      }
    });
    //login with success and error
    login("admin", "admin").onComplete(event -> {
      if (event.failed()) {
        System.out.println(event.cause().getMessage());
      } else {
        System.out.println(event.result());
      }
    });
    //login with failure data
    login("foo", "bar").onComplete(event -> {
      if (event.failed()) {
        System.out.println(event.cause().getMessage());
      } else {
        System.out.println(event.result());
      }
    });
  }
}
.....................................................................................
Shortcuts for Listener Code;
.............................

Listener api Which returns Future.

Syntax:
someApi().onComplete(Handler<AsynResult>)
someApi().onSuccess(res->{});
someApi().onError(err->{});
someApi().onSuccess(res->{}).onError(err->{});
someApi().onSuccess(System.out::println).onError(System.out::println);

package com.amex.futures;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Future;
import io.vertx.core.Launcher;

public class FutureWithData extends AbstractVerticle {
  public static void main(String[] args) {
    Launcher.executeCommand("run", FutureWithData.class.getName());
  }

  //Return data with Future.
  public Future<String> sayHello() {
    return Future.future(future -> future.complete("Hello"));
  }

  //return error data with Future
  public Future<String> getError() {
    return Future.future(future -> future.fail("Something went wrong!"));
  }

  //future with biz logic
  public Future<String> login(String userName, String password) {

    return Future.future(handler -> {
      //biz logic
      if (userName.equals("admin") && password.equals("admin")) {
        handler.complete("Login Success");
      } else {
        handler.fail("Login failed");
      }
    });

  }

  @Override
  public void start() throws Exception {
    super.start();
    //short cut apis
    //sayHello().onSuccess(res -> System.out.println(res));
    sayHello().onSuccess(System.out::println);
    getError().onFailure(System.out::println);
    login("admin", "admin")
      .onSuccess(System.out::println)
      .onFailure(System.out::println);
  }
}
.....................................................................................
			Callback Chaining
.....................................................................................

In sequential programming/sync programming , the flow of the program like below.

//jdbc workflow

Connection con = DriverManger.getConnection();
Statement st = con.createStatement();
ResultSet rows =st.executeQuery("select * from orders")
while(rows.next()){
  System.out.println(rows.getInt(0)));
}
Here flow will go one after another.

What if the same task can be done in functional programming or async way:Vertx.

Functional way of writing sequential work flow.
   Nested Callbacks/callback chaining/functional Style.

Handler function is called as callback function.

"The output of one callback is input to the another callback , nested callback.

cb1
   ---cb2
       |
        ------
       cb3
	|
	|	
	---------
	|
	|
	cb4 
	 |
	 |
	 --------
	  |
	  cbN
	    |
	    process the result.

Use Case:
   getUser -  if user is available(Success)
	|
	 --------call login with output of getUser
        |
      if failed
         |
        you can throw error.

package com.mycom.futures.callbacks;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Future;
import io.vertx.core.Launcher;

public class CallbackVerticle extends AbstractVerticle {

  public static void main(String[] args) {
    Launcher.executeCommand("run", CallbackVerticle.class.getName());

  }

  public Future<User> getUser() {
    System.out.println("Get User is called");
    User user = new User("admin", "admin");
    //
   // user = null;
    if (user != null) {
      return Future.succeededFuture(user);
    } else {
      return Future.failedFuture("User not Found");
    }
  }

  //login
  public Future<String> login(String userName, String password) {
    System.out.println("Login is called");
    //biz logic
    if (userName.equals("admin") && password.equals("admin")) {
      return Future.succeededFuture("Login is success");
    } else {
      return Future.failedFuture("Login is failed");
    }
  }

  public Future<String> showDashboard(String status) {
    System.out.println("ShowDashboard is called");
    if (status.equals("Login is success")) {
      return Future.succeededFuture("Welcome to admin");
    } else {
      return Future.failedFuture("Welcome to Guest");
    }
  }

  @Override
  public void start() throws Exception {
    super.start();
    getUser().onComplete(userHandler -> {
      if (userHandler.failed()) {
        System.out.println(userHandler.cause().getMessage());
      } else {
        User user = userHandler.result();
        // System.out.println(user.getUserName() + " " + user.getPassword());
        //call login
        login(user.getUserName(), user.getPassword()).onComplete(loginHandler -> {
          if (loginHandler.failed()) {
            System.out.println(loginHandler.cause().getMessage());
          } else {
            //System.out.println(loginHandler.result());
            showDashboard(loginHandler.result()).onComplete(dashboardHandler -> {
              if (dashboardHandler.failed()) {
                System.out.println(dashboardHandler.cause());
              } else {
                System.out.println(dashboardHandler.result());
              }
            });
          }
        });
      }
    });
  }
}
....................................................................................
			 Calback Hell
............................................................................

    getUser().onComplete(userHandler -> {
      if (userHandler.failed()) {
        System.out.println(userHandler.cause().getMessage());
      } else {
        User user = userHandler.result();
        // System.out.println(user.getUserName() + " " + user.getPassword());
        //call login
        login(user.getUserName(), user.getPassword()).onComplete(loginHandler -> {
          if (loginHandler.failed()) {
            System.out.println(loginHandler.cause().getMessage());
          } else {
            //System.out.println(loginHandler.result());
            showDashboard(loginHandler.result()).onComplete(dashboardHandler -> {
              if (dashboardHandler.failed()) {
                System.out.println(dashboardHandler.cause());
              } else {
                System.out.println(dashboardHandler.result());
              }
            });
          }
        });
      }
    });


Look at the above code, ask your self

1.is it easy to understand
2.is it easy to scale
3.is it easy to maintain.

 No.

This is called callback hell, the callback hell is way of writing complex callback based programming.

Can we escape from the callback hell problem, or how to write better callback based programming.

Yes!

Solution 1:
  private void doSolutionOne() {
    getUser().onSuccess(user -> {
      login(user.getUserName(), user.getPassword()).onSuccess(status -> {
        showDashboard(status).onSuccess(dashboard -> {
          System.out.println(dashboard);
        }).onFailure(err -> {
          System.out.println(err);
        });
      }).onFailure(err -> {
        System.out.println(err);
      });
    }).onFailure(err -> {
      System.out.println(err.getMessage());
    });
  }

Solution 2:
Using Future.compose method
  private void doSolutionTwo() {
    getUser().compose(user -> {
      return login(user.getUserName(), user.getPassword());
    }).compose(status -> {
      return showDashboard(status);
    }).onSuccess(res -> {
      System.out.println(res);
    }).onFailure(err -> {
      System.out.println(err);
    });
  }

2.1.Using compose but code refactoring using java functional programming concepts

if function has no any code, only return statement, then we can remove {} and return statement - Lambda refactoring..


    //lambda refactoring
    getUser()
      .compose(user->login(user.getUserName(), user.getPassword()))
      .compose(status->showDashboard(status))
      .onSuccess(res -> {
      System.out.println(res);
    }).onFailure(err -> {
      System.out.println(err);
    });

2.2.Using Compose,and Using Java 8 method References , instead of lambda syntax , we use method Reference.

Note: method reference works on single variable,so we refeactor our parameter from username,password into object called user.

   getUser()
      .compose(this::login)
      .compose(this::showDashboard)
      .onSuccess(System.out::println)
      .onFailure(System.out::println);


Full Code:

package com.mycom.futures.callbacks;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Future;
import io.vertx.core.Launcher;

public class CallbackHellSolutionVerticle extends AbstractVerticle {

  public static void main(String[] args) {
    Launcher.executeCommand("run", CallbackHellSolutionVerticle.class.getName());

  }

  public Future<User> getUser() {
    System.out.println("Get User is called");
    User user = new User("admin", "admin");
    //
    // user = null;
    if (user != null) {
      return Future.succeededFuture(user);
    } else {
      return Future.failedFuture("User not Found");
    }
  }

  //login
  public Future<String> login(User user) {
    System.out.println("Login is called");
    //biz logic
    if (user.getUserName().equals("admin") && user.getPassword().equals("admin")) {
      return Future.succeededFuture("Login is success");
    } else {
      return Future.failedFuture("Login is failed");
    }
  }

  public Future<String> showDashboard(String status) {
    System.out.println("ShowDashboard is called");
    if (status.equals("Login is success")) {
      return Future.succeededFuture("Welcome to admin");
    } else {
      return Future.failedFuture("Welcome to Guest");
    }
  }

  //soultion 1:
  private void doSolutionOne() {
    getUser().onSuccess(user -> {
      login(user).onSuccess(status -> {
        showDashboard(status).onSuccess(dashboard -> {
          System.out.println(dashboard);
        }).onFailure(err -> {
          System.out.println(err);
        });
      }).onFailure(err -> {
        System.out.println(err);
      });
    }).onFailure(err -> {
      System.out.println(err.getMessage());
    });
  }

  //Using Future.compose
  private void doSolutionTwo() {
    getUser().compose(user -> {
      return login(user);
    }).compose(status -> {
      return showDashboard(status);
    }).onSuccess(res -> {
      System.out.println(res);
    }).onFailure(err -> {
      System.out.println(err);
    });

    //lambda refactoring
    getUser()
      .compose(user->login(user))
      .compose(status->showDashboard(status))
      .onSuccess(res -> {
        System.out.println(res);
      }).onFailure(err -> {
        System.out.println(err);
      });

    //method Reference
    getUser()
      .compose(this::login)
      .compose(this::showDashboard)
      .onSuccess(System.out::println)
      .onFailure(System.out::println);
  }

  @Override
  public void start() throws Exception {
    super.start();
    //Solution 1:
    //doSolutionOne();
    //Solution 2:
    doSolutionTwo();
  }
}
.......................................

Callback Chaining:

1.using onComplete with handler
2.using OnSuccess and OnFailure
3.Using compose method
   ->using normal compose
   ->using lambdba 
   ->using method reference
.....................................................................................
			Advanced Composition: CompsiteFuture
.....................................................................................

Lets i have i have three methods

1.startDbServer
2.startHttpServer
3.startConfigServer

I need to ensure that my app must initalized only, all servers are up, if any one server is failed, stop all servers , dont initalize my app.


Future Coordintation:

   Coordination of multiple futures can be achived with Vertx Futures

Vertx supports cocurrent compostion(runnin serveral async operations in parall) and code looks sequentail - chaining async operations.

Methods:
 CompositeFuture.all() or Future.all() - all should succeed , then only you have to  start app
 CompsiteFuture.any() or Future.any()-any one succeed you can run app

package com.mycom.futures.callbacks;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.CompositeFuture;
import io.vertx.core.Future;
import io.vertx.core.Launcher;

public class CompositeFutureVerticle extends AbstractVerticle {

  public static void main(String[] args) {
    Launcher.executeCommand("run", CompositeFutureVerticle.class.getName());

  }

  public Future<String> startDbServer() {
    System.out.println("DB server started");
    return Future.succeededFuture("DB server is up");
  }

  public Future<String> startHttpServer() {
    System.out.println("HTTP server started");
    return Future.succeededFuture("HttpServer  is up");
  }

  public Future<String> startConfigServer() {
    System.out.println("Config server started");
    return Future.succeededFuture("ConfigServer  is up");
  }

  @Override
  public void start() throws Exception {
    super.start();
    Future<String> dbServer = startDbServer();
    Future<String> webServer = startHttpServer();
    Future<String> configServer = startConfigServer();
    //
    CompositeFuture.all(dbServer, webServer, configServer).onComplete(ar -> {
      if (ar.succeeded()) {
        System.out.println("All servers are up");
        //do something else
      } else {
        System.out.println(ar.cause().getMessage());
      }
    });
    //Using Future:
    Future.all(dbServer, webServer, configServer).onComplete(ar -> {
      if (ar.succeeded()) {
        System.out.println("All servers are up");
        //do something else
      } else {
        System.out.println(ar.cause().getMessage());
      }
    });

    Future.all(dbServer, webServer, configServer)
      .onSuccess(System.out::println)
      .onFailure(System.out::println);
  }
}
....................................................................................
			 Promises
.....................................................................................

If Futures are read side of async result where as Promises are "write side" of async results.

Promises are insired from java script language.

Promises are semantically meaningfull abstrcation for handling async result.

Most of the developers confuse the Java Future and Vert.x Future, in order to avoid confusion, Promises were introduced.

Promises cant be processed directly with "OnComplete/OnSuccess" api 

Promises need to converted into Future before Processing.


How to create Promise and process promises?
package com.mycom.promises;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Future;
import io.vertx.core.Launcher;
import io.vertx.core.Promise;

public class PromiseVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Launcher.executeCommand("run", PromiseVerticle.class.getName());
  }

  //create Promise and encaspulate Data
  public Promise<String> getHelloPromise() {
    Promise promise = Promise.promise();
    promise.complete("Hello");
    return promise;
  }

  public Future<String> getHaiPromise() {
    Promise promise = Promise.promise();
    promise.complete("Hai");
    return promise.future();
  }

  @Override
  public void start() throws Exception {
    super.start();
    getHelloPromise().future().onSuccess(System.out::println);
    getHaiPromise().onSuccess(System.out::println);
  }
}
.....................................................................................			 Verticle start and stop method with Promises
.....................................................................................

Async Verticle start and stop methods:

 Sometimes you want to do something in your verticle startup which may takes some time and you dont want  the verticle to be considered deployed untile that happens.

for eg, you might want to start an http server start method and propagate the async result of server listen method.

The way to do is to implement the async start method(Start with method with promise as arg)
 This version of start method takes promise as a parameter, when the method returns verticle will not be considered deployed.

Every Verticle will have unique deploymentId, which can be to undeploy verticles



package com.mycom.promises;

import com.mycom.HelloWorldVerticle;
import io.vertx.core.AbstractVerticle;
import io.vertx.core.Launcher;
import io.vertx.core.Promise;

public class PromiseStartVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Launcher.executeCommand("run", PromiseStartVerticle.class.getName());
  }
  //start

  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    vertx.deployVerticle(new HelloWorldVerticle(), ar -> {
      if (ar.succeeded()) {
        System.out.println(HelloWorldVerticle.class.getName() + " " + "Deployment Id is " + ar.result());
        //startPromise.complete();
        startPromise.future().onSuccess(event -> {
          System.out.println("App is ready");
        });
      } else {
        startPromise.future().onFailure(event -> {
          System.out.println("App is failed");
        });
      }

    });
  }
}

.....................................................................................	
			 Building Non blocking or Async apps
.....................................................................................

in order to build non blocking io apps (network,filesystem) and timers, language or framework/lib/toolkit has to provide basic requirment.

1.Runtime should have faciltity to talk to low level operating system non blocking apis such as "select/poll/epoll-linux, iocp-windows,kqueue-mac,unix".

2.For Application developers , the language or framework/lib/toolkit must provide high level apis in order to communicate low level system calls api - vertx provides high level apis.

3.At runtime level, Runtime must provide threading features to listen for os kernal events. Event loop threads.

4.Program level, we must bind function to handle such events(callbacks)

Vertx non blocking apis:
.......................

1.Timer 
2.File System
3.Http Api
4.Socket api
5.Udp and DataGram 
etc....


Timer:
......

It is common in vertx to want to perform some action after a certain delay or perdically.

Timer is special non blocking api which schdules any task in delayed manner which does not block the current thread.

Task is executed by "CPU" level.

Timer is not part of FileDecriptor table because it is not an IO operation.


Types of timers:
1.one-shot timers
2.Periodic timers.

one-shot Timers:


package com.mycom.nonblocking.timers;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Launcher;
import io.vertx.core.Promise;

public class OneShortTimerVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Launcher.executeCommand("run", OneShortTimerVerticle.class.getName());
  }

  private void blockMe(String message) {
    System.out.println(message);
  }

  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    //timer
    blockMe("start");
    vertx.setTimer(1000, handler -> {
      System.out.println("I am delayed task");
    });
    blockMe("end");
  }
}
..................................................................................


How to transfer data with timer?
package com.mycom.nonblocking.timers;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Future;
import io.vertx.core.Launcher;
import io.vertx.core.Promise;

public class TimerWithDataVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Launcher.executeCommand("run", TimerWithDataVerticle.class.getName());
  }

  private void blockMe(String message) {
    System.out.println(message);
  }

  public Future<String> getMessage() {
    return Future.future(ar -> {
      String response = "Hello Timer!";
      vertx.setTimer(1000, handler -> {
        ar.complete(response);
      });
    });
  }

  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    //timer
    blockMe("start");
    getMessage().onSuccess(System.out::println);
    blockMe("end");
  }
}
...................................................................................
   	Passing data using callback pattern-Higher order function


package com.mycom.nonblocking.timers;

import io.vertx.core.*;


public class TimerWIthHigherOrderVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Launcher.executeCommand("run", TimerWIthHigherOrderVerticle.class.getName());
  }

  private void blockMe(String message) {
    System.out.println(message);
  }

  public void getMessage(Handler<AsyncResult<String>> aHandler) {
    vertx.setTimer(1000, timerHandler -> {
      String res = "Hello How are you";
      aHandler.handle(Future.succeededFuture(res));
    });
  }

  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    //timer
    blockMe("start");
    getMessage(aRes -> {
      System.out.println(aRes.result());
    });
    blockMe("end");
  }
}
....................................................................................
			Periodic Timers
...................................................................................

Periodic timers are used to send data infinitely.


package com.mycom.nonblocking.timers;

import io.vertx.core.AbstractVerticle;
import io.vertx.core.Launcher;
import io.vertx.core.Promise;

public class PeriodicTimerVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Launcher.executeCommand("run", PeriodicTimerVerticle.class.getName());
  }

  public void tick() {
    vertx.setPeriodic(1000, handler -> {
      System.out.println(Math.random());
    });
  }

  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    tick();
  }
}
..................................................................................
			How to return data From Periodic timer
..................................................................................

package com.mycom.nonblocking.timers;

import io.vertx.core.*;

public class PeriodicTimerVerticle extends AbstractVerticle {
  public static void main(String[] args) {
    Launcher.executeCommand("run", PeriodicTimerVerticle.class.getName());
  }

  public void poll(Handler<AsyncResult<Double>> aHandler) {
    vertx.setPeriodic(1000, handler -> {
      //Future.succeededFuture(Math.random());
      aHandler.handle(Future.succeededFuture(Math.random()));
    });
  }

  @Override
  public void start(Promise<Void> startPromise) throws Exception {
    super.start(startPromise);
    poll(res -> {
      System.out.println(res.result());
    });
  }
}












